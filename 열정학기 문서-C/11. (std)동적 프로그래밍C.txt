11. 동적 프로그래밍
동적프로그래밍(dynamic programming)은 어떤 문제를 풀기 위해
그 문제를 여러 개의 작은 문제로 나누어 푼 다음,
그것을 결합하여 원래의 문제를 해결하는 방법입니다.

동적프로그래밍은 분할정복과 유사한 방법이지만,
동적프로그래밍은 작은 문제들이 서로 중복되는 경우가 많습니다.
이러한 중복되는 작은 문제들을 한 번만 풀어서 그 결과를 저장해 놓고,
다시 그 작은 문제가 나타나면 저장해 놓은 결과를 그대로 사용하는 방법입니다.
이러한 방법을 메모이제이션(memoization)이라고 합니다.

11.1. 피보나치 수열
피보나치 수열은 다음과 같이 정의된 수열입니다.

f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2) (n >= 2)

N번째 피보나치 수열을 구하는 문제를 풀어봅시다.(단 0 < N < 100)
[
    #include <stdio.h>

    int main(){
        int n;
        int f[100];

        scanf("%d", &n);

        f[0] = 0;
        f[1] = 1;
        for(int i=2; i<=n; i++){
            f[i] = f[i-1] + f[i-2];
        }

        printf("%d\n", f[n]);

        return 0;
    }
]
실행결과는 다음과 같습니다.

(예를들어 10을 입력)
55

11.2. 2×n 타일링
https://www.acmicpc.net/problem/11726

2×n 크기의 직사각형을 2×1, 1×2 타일로 채우는 방법의 수를 구하는 문제입니다.
첫째 줄에 n이 주어집니다. (1 ≤ n ≤ 1,000)
첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.

[
    #include <stdio.h>

    int main(){
        int n;
        int d[1001];

        scanf("%d", &n);

        d[0] = 1;
        d[1] = 1;
        for(int i=2; i<=n; i++){
            d[i] = d[i-1] + d[i-2];
            d[i] %= 10007;
        }

        printf("%d\n", d[n]);

        return 0;
    }
]
실행결과는 다음과 같습니다.

(예를들어 9를 입력)
55

11.3. 최대 부분 증가 수열
LIS(Longest Increasing Subsequence) 문제는 다음과 같은 문제입니다.

N개의 수로 이루어진 수열이 주어졌을 때,
가장 긴 증가하는 부분 수열의 길이를 구하는 문제입니다.
예를 들어, 수열 {10, 20, 10, 30, 20, 50}의 가장 긴 증가하는 부분 수열은
{10, 20, 30, 50} 이고, 길이는 4입니다.

N(1 ≤ N ≤ 1,000)이 주어지고,
다음 줄에 N개의 수가 주어집니다.

첫째 줄에 수열의 가장 긴 증가하는 부분 수열의 길이를 출력합니다.

[
    #include <stdio.h>

    int main(){
        int n;
        int a[1001];
        int d[1001];

        scanf("%d", &n);
        for(int i=1; i<=n; i++){
            scanf("%d", &a[i]);
        }

        for(int i=1; i<=n; i++){
            d[i] = 1;
            for(int j=1; j<i; j++){
                if(a[j] < a[i] && d[i] < d[j] + 1){
                    d[i] = d[j] + 1;
                }
            }
        }

        int ans = d[1];
        for(int i=2; i<=n; i++){
            if(ans < d[i]){
                ans = d[i];
            }
        }

        printf("%d\n", ans);

        return 0;
    }
]
실행결과는 다음과 같습니다.

(예를들어
6
10 20 10 30 20 50
을 입력)
4

위 풀이의 시간복잡도는 O(N^2)입니다.
하지만 이 문제는 O(NlogN)의 시간복잡도로 풀 수 있습니다.
이를 위해서는 이분 탐색을 사용해야 합니다.
이분 탐색을 사용한 풀이법은 이분탐색을 다루고 나서 한번 더 다뤄보도록 하겠습니다.

11.4. 냅색 문제
냅색 문제는 DP문제 중에서도 가장 기본적인 문제입니다.
냅색 문제는 다음과 같은 문제입니다.

N개의 물건과 가용 무게 W를 가지고 있습니다.
각 물건은 무게와 가치가 있습니다.
이 물건들 중에서 몇 개를 골라서 무게의 합이 가용 무게 W를 넘지 않도록 하면서,
가치의 합을 최대로 하는 문제입니다.

첫째 줄에 N(1 ≤ N ≤ 100)과 W(1 ≤ W ≤ 10,000)가 주어집니다.
다음 N개의 줄에는 각 물건의 무게와 가치가 주어집니다.

첫째 줄에 가방에 넣을 수 있는 물건들의 가치의 합의 최댓값을 출력합니다.

[
    #include <stdio.h>

    int max(int a, int b){
        return a > b ? a : b;
    }

    int main(){
        int n, w;
        int a[101];
        int b[101];
        int d[10001];

        scanf("%d %d", &n, &w);
        for(int i=1; i<=n; i++){
            scanf("%d %d", &a[i], &b[i]);
        }

        for(int i=1; i<=n; i++){
            for(int j=w; j>=1; j--){
                if(j-a[i] >= 0){
                    d[j] = max(d[j], d[j-a[i]] + b[i]);
                }
            }
        }

        printf("%d\n", d[w]);

        return 0;
    }
]
실행결과는 다음과 같습니다.

(예를들어
4 7
6 13
4 8
3 6
5 12
를 입력)
14

11.5. 구간합 문제
구간합 문제는 다음과 같은 문제입니다.

N개의 수가 주어집니다.
그리고 M개의 질문(쿼리)이 주어집니다.
각 질문(쿼리)은 L과 R이 주어집니다.
이때 L부터 R까지의 합을 구하는 문제입니다.

첫째 줄에 N(1 ≤ N ≤ 100,000)과 M(1 ≤ M ≤ 100,000)이 주어집니다.
다음 N개의 줄에는 N개의 수가 주어집니다.
다음 M개의 줄에는 L과 R이 주어집니다.

각 질문(쿼리)에 대한 답을 한 줄에 하나씩 출력합니다.

[
    #include <stdio.h>

    int main(){
        int n, m;
        int a[100001];
        int d[100001];

        scanf("%d %d", &n, &m);
        for(int i=1; i<=n; i++){
            scanf("%d", &a[i]);
            d[i] = d[i-1] + a[i];
        }

        while(m--){
            int l, r;
            scanf("%d %d", &l, &r);
            printf("%d\n", d[r] - d[l-1]);
        }

        return 0;
    }
]
실행결과는 다음과 같습니다.

(예를들어
5 3                 // 5개의 수가 주어지고 3개의 질문(쿼리)이 주어짐
10 20 30 40 50      // 5개의 수가 주어짐
1 3                 // 1부터 3까지의 합을 구하는 질문(쿼리)
2 4                 // 2부터 4까지의 합을 구하는 질문(쿼리)
3 5                 // 3부터 5까지의 합을 구하는 질문(쿼리)
를 입력)
60                  // 1부터 3까지의 합을 구하는 질문(쿼리)의 답
90
120

동적계획법은 최적화 문제와 관련된 알고리즘이기에
필수적으로 사용할 필요는 없지만
시간복잡도를 대폭 줄일 수 있는 문제들이 많아 자주 사용합니다.