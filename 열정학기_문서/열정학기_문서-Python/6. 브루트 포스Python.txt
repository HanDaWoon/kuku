
6. 브루트 포스 알고리즘
brute force 알고리즘이란 모든 경우의 수를 대입하여
결과를 도출하는 방법입니다.

6.1. 3N + 1문제
    콜라츠 추측이란 주어진 수가 1이 될 때까지 다음 작업을 반복하는 수열을 만들어 내는 것입니다.
    콜라츠 추측이라고도 불리는 3N + 1문제는 다음과 같습니다.
    1. 주어진 수가 짝수라면 2로 나눕니다.
    2. 주어진 수가 홀수라면 3을 곱하고 1을 더합니다.
    3. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.

    예를 들어, 주어진 수가 6이라면 수열은 다음과 같습니다.
    6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1
    
    위 수열에서 보듯이 총 8번 만에 1이 됩니다.
    이렇게 주어진 수가 1이 될 때까지 위 작업을 반복하면
    어떤 수든 1이 됩니다.
    그리고 이렇게 원래 수로 돌아오는 작업을 반복할 때,
    가장 많은 작업을 반복해야 하는 수는 얼마일까요?
    이를 알아내는 프로그램을 작성해 봅시다.

    <!-- 어떤 양의 정수 N에 대하여,
    N이 홀수라면 3N + 1을 하고,
    N이 짝수라면 N을 2로 나눈다고 가정할 때,
    모든 양의 정수 N에 대하여 위의 과정을 반복하면
    결국 1에 도달하게 된다는 추측입니다. -->

    문제가 간단해보여 직접 계산 하지않고 N에 따라 값을 구하는
    공식이 존재 할것 같지만, 아직까지 값을 구하는 공식이 밝혀지지 않았습니다.

    N을 입력받아 처음 1에 도달할때까지 걸리는 횟수를 출력하시오.

n = int(input("n: "))
cnt = 0
while n != 1:
    if n % 2 == 0:  # 짝수
        n = n // 2  
    else:
        n = 3 * n + 1   
    cnt += 1
print(cnt)

    실행결과는 다음과 같습니다.
        n: 22
        15


    6.2. 집합의 부분집합 중 힙이 0이 있는지 판별하기
    어떤 정수 집합이 주어졌을때, 그 집합의 일부 원소를 선택하여 하나의 집합을
    이룬다면 이를 부분집합이라 합니다.
    이때, 부분집합의 원소들의 합이 0이 되는 부분집합이 존재하는지
    판정하는 문제는 유명한 NP-완전 문제입니다.
    현재까지는 이 문제를 더 빠르게 푸는 방법이 발견되지 않았습니다.
    입력은 다음과 같이 주어집니다.
    첫째 줄에 집합의 크기 N이 주어지고,
    둘째 줄에 N개의 정수 집합이 주어집니다.
    (단, N은 20 이하의 자연수, 집합의 원소는 -1000 이상 1000 이하의 정수)
n = int(input("n: "))
a = list(map(int, input("a: ").split()))
for i in range(1 &lt;&lt; n):  # << : 비트연산자, 
    sum = 0 
    for j in range(n):
        if i & (1 &lt;&lt; j):
            sum += a[j]
    if sum == 0:    # 부분집합의 합이 0이면
            print("YES")    # YES 출력
            break
    else:
        print("NO")

    실행결과는 다음과 같습니다.
        n: 5
        a: 1 2 3 4 5
        YES

    이 문제는 부분집합의 개수만큼 반복문을 돌리는데,
    부분집합의 개수는 2^N개입니다.
    그리고 각 부분집합마다 부분집합의 원소들의 합을 구하는데,
    이때 각 원소를 구하기 위해서는 N번의 비트연산을 해야합니다.
    따라서 이 문제의 시간복잡도는 O(2^N * N)입니다.

    6.3. 분해합 문제
    Asia Regional - Seoul 2005 B번
    어떤 자연수 N이 있을때, 그 자연수의 분해합은 N과 N을 이루는 각 자리수의
    합을 의미합니다.
    어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라고 합니다.
    예를 들어, 245의 분해합은 256(=245+2+4+5)이므로 245는 256의 생성자입니다.
    물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있습니다.
    반대로, 생성자가 여러 개인 자연수도 있습니다.
    생성자가 없는 자연수 중에서 가장 큰 수는 1,000,000입니다.
    생성자가 여러 개인 자연수 중에서 가장 작은 수는 10,000입니다.
    입력은 다음과 같이 주어집니다.
    첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어집니다.
n = int(input("n: "))
for i in range(1, n):
    sum = i # 생성자
    temp = i    # 자릿수를 구하기 위한 변수
    while temp: # 자릿수를 구하는 반복문
        sum += temp % 10    # 자릿수를 더해줌
        temp //= 10 # 자릿수를 없애줌
    if sum == n:    # 생성자가 n과 같으면
        print(i)    # 생성자 출력
        break
    else:
        print(0)    # 생성자가 없으면 0 출력


n = int(input("n: "))
for i in range(1, n):
    sum = i
    for j in str(i):        # 각 자리수를 구하기 위해 문자열로 변환
        sum += int(j)       # 각 자리수를 더함
    if sum == n:            # 분해합이 n과 같으면
        print(i)            # 생성자 출력
        break
    if i == n-1:            # 생성자가 없는 경우
        print(0)            # 0 출력

    실행결과는 다음과 같습니다.
        n: 216
        198

    이 문제는 1부터 N-1까지의 수를 하나씩 더해가면서 각 수의 분해합이 N이 되는지 확인하는 방법으로 풀었습니다.
    이때 각 수의 분해합을 구하기 위해서는 각 자리수를 구해야하는데, 이때 각 자리수를 구하기 위해서는 10으로 나누는 연산을 해야합니다.
    따라서 이 문제의 시간복잡도는 O(N * logN)입니다.(logN이 자리수에 가까움)

