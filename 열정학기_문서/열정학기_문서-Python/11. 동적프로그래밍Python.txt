11. 동적 프로그래밍
동적프로그래밍(dynamic programming)은 어떤 문제를 풀기 위해
그 문제를 여러 개의 작은 문제로 나누어 푼 다음,
그것을 결합하여 원래의 문제를 해결하는 방법입니다.

동적프로그래밍은 분할정복과 유사한 방법이지만,
동적프로그래밍은 작은 문제들이 서로 중복되는 경우가 많습니다.
이러한 중복되는 작은 문제들을 한 번만 풀어서 그 결과를 저장해 놓고,
다시 그 작은 문제가 나타나면 저장해 놓은 결과를 그대로 사용하는 방법입니다.
이러한 방법을 메모이제이션(memoization)이라고 합니다.

11.1. 피보나치 수열
피보나치 수열은 다음과 같이 정의된 수열입니다.

f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2) (n >= 2)

N번째 피보나치 수열을 구하는 문제를 풀어봅시다.(단 0 < N < 100)

n = int(input())
f = [0]*100
f[0] = 0
f[1] = 1
for i in range(2, n+1):
    f[i] = f[i-1] + f[i-2]
print(f[n])

실행결과는 다음과 같습니다.

입력: 10
55

11.2. 2×n 타일링

백준 11726번
https://www.acmicpc.net/problem/11726

2×n 크기의 직사각형을 2×1, 1×2 타일로 채우는 방법의 수를 구하는 문제입니다.
첫째 줄에 n이 주어집니다. (1 ≤ n ≤ 1,000)
첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.

n = int(input())
d = [0]*1001
d[0] = 1
d[1] = 1

for i in range(2, n+1):
    d[i] = d[i-1] + d[i-2]  # d[i-1]은 1x2 타일을 놓는 경우, d[i-2]는 2x1 타일을 놓는 경우
    d[i] %= 10007   
print(d[n])

실행결과는 다음과 같습니다.

입력: 9
55

11.3. 최대 부분 증가 수열
LIS(Longest Increasing Subsequence) 문제는 다음과 같은 문제입니다.

N개의 수로 이루어진 수열이 주어졌을 때,
가장 긴 증가하는 부분 수열의 길이를 구하는 문제입니다.
예를 들어, 수열 {10, 20, 10, 30, 20, 50}의 가장 긴 증가하는 부분 수열은
{10, 20, 30, 50} 이고, 길이는 4입니다.

N(1 ≤ N ≤ 1,000)이 주어지고,
다음 줄에 N개의 수가 주어집니다.

첫째 줄에 수열의 가장 긴 증가하는 부분 수열의 길이를 출력합니다.

n = int(input())
a = [0] * 1001  # 수열
d = [0]*1001
a = list(map(int, input().split()))

for i in range(n):
    d[i] = 1    
    for j in range(i):
        if a[j] < a[i] and d[i] < d[j]+1:   
            d[i] = d[j] + 1   
    
ans = d[1]  # 가장 긴 증가하는 부분 수열의 길이
for i in range(2, n+1):
    if(ans<d[i]):   # 가장 긴 증가하는 부분 수열의 길이를 구함
        ans = d[i]
print(ans)  


    

위 풀이의 시간복잡도는 O(N^2)입니다.
하지만 이 문제는 O(NlogN)의 시간복잡도로 풀 수 있습니다.
이를 위해서는 이분 탐색을 사용해야 합니다.
이분 탐색을 사용한 풀이법은 이분탐색을 다루고 나서 한번 더 다뤄보도록 하겠습니다.

11.4. 냅색 문제
냅색 문제는 DP문제 중에서도 가장 기본적인 문제입니다.
냅색 문제는 다음과 같은 문제입니다.

N개의 물건과 가용 무게 W를 가지고 있습니다.
각 물건은 무게와 가치가 있습니다.
이 물건들 중에서 몇 개를 골라서 무게의 합이 가용 무게 W를 넘지 않도록 하면서,
가치의 합을 최대로 하는 문제입니다.

첫째 줄에 N(1 ≤ N ≤ 100)과 W(1 ≤ W ≤ 10,000)가 주어집니다.
다음 N개의 줄에는 각 물건의 무게와 가치가 주어집니다.

첫째 줄에 가방에 넣을 수 있는 물건들의 가치의 합의 최댓값을 출력합니다.

def max(a, b):
    if a > b:
        return a
    else:
        return b

n, w = map(int, input().split())
a = [0] * 101   # 물건의 무게
b = [0] * 101   # 물건의 가치
d = [0] * 10001 

for i in range(1, n+1):
    a[i], b[i] = map(int, input().split())

for i in range(1, n+1):
    for j in range(w, 1, -1):   # w부터 1까지 역순으로
        if j - a[i] >= 0:    # 물건의 무게가 j보다 작으면
            d[j] = max(d[j], d[j-a[i]] + b[i])  # d[j] = j무게를 넣을 수 있는 최대 가치

print(d[w]) # 넣을 수 있는 물건들의 가치의 합의 최댓값

실행결과는 다음과 같습니다.

입력
4 7
6 13
4 8
3 6
5 12

출력
14

11.5. 구간합 문제
구간합 문제는 다음과 같은 문제입니다.

N개의 수가 주어집니다.
그리고 M개의 질문(쿼리)이 주어집니다.
각 질문(쿼리)은 L과 R이 주어집니다.
이때 L부터 R까지의 합을 구하는 문제입니다.

첫째 줄에 N(1 ≤ N ≤ 100,000)과 M(1 ≤ M ≤ 100,000)이 주어집니다.
다음 N개의 줄에는 N개의 수가 주어집니다.
다음 M개의 줄에는 L과 R이 주어집니다.

각 질문(쿼리)에 대한 답을 한 줄에 하나씩 출력합니다.

n, m = map(int, input().split())
a = [0] * 100001    
d = [0] * 100001
a = list(map(int, input().split()))
for i in range(1, n+1):
    d[i] = d[i-1] + a[i]

while m > 0:
    l, r = map(int, input().split())
    print(d[r] - d[l-1])
    m -= 1

동적계획법은 최적화 문제와 관련된 알고리즘이기에
필수적으로 사용할 필요는 없지만
시간복잡도를 대폭 줄일 수 있는 문제들이 많아 자주 사용합니다.
